{
  "hooks": [
    {
      "id": "use-copy-to-clipboard",
      "name": "UseCopyToClipboard",
      "description": "Provides a simple way to copy text to the clipboard.",
      "category": "Utilities",
      "package": "hook",
      "filePath": "packages\\hook\\src\\hooks\\use-copy-to-clipboard.ts",
      "parameters": [],
      "returns": {
        "type": "[string, (text: string) => Promise<void>]"
      },
      "sourceCode": "import { useState } from \"react\";\r\n\r\ntype CopiedValueType = string | null;\r\n\r\n/**\r\n * Provides a simple way to copy text to the clipboard.\r\n */\r\nexport function useCopyToClipboard(): [\r\n  CopiedValueType,\r\n  (text: string) => Promise<void>,\r\n] {\r\n  const [copiedText, setCopiedText] = useState<CopiedValueType>(null);\r\n\r\n  const copy = async (text: string): Promise<void> => {\r\n    if (!navigator?.clipboard) {\r\n      console.warn(\"Clipboard not supported\");\r\n      return;\r\n    }\r\n\r\n    try {\r\n      await navigator.clipboard.writeText(text);\r\n      setCopiedText(text);\r\n    } catch (error) {\r\n      console.log(\"Error\", error);\r\n      setCopiedText(null);\r\n    }\r\n  };\r\n\r\n  return [copiedText, copy];\r\n}\r\n"
    },
    {
      "id": "use-countdown",
      "name": "UseCountdown",
      "description": "A custom hook for a countdown timer.",
      "category": "Utilities",
      "package": "hook",
      "filePath": "packages\\hook\\src\\hooks\\use-countdown.ts",
      "parameters": [
        {
          "name": "initialSeconds",
          "type": "number",
          "required": true
        }
      ],
      "returns": {
        "type": "[number, () => void]"
      },
      "sourceCode": "import { useEffect, useState } from \"react\";\r\n\r\n/**\r\n * A custom hook for a countdown timer.\r\n * @param initialSeconds - The starting number of seconds for the countdown.\r\n * @returns An array containing the current countdown time and a function to reset the countdown.\r\n */\r\nexport function useCountdown(initialSeconds: number): [number, () => void] {\r\n  const [timeLeft, setTimeLeft] = useState<number>(initialSeconds);\r\n\r\n  const reset = () => setTimeLeft(initialSeconds);\r\n\r\n  useEffect(() => {\r\n    if (timeLeft <= 0) return;\r\n\r\n    const intervalId = setInterval(() => {\r\n      setTimeLeft((prev) => prev - 1);\r\n    }, 1000);\r\n\r\n    return () => clearInterval(intervalId);\r\n  }, [timeLeft]);\r\n\r\n  return [timeLeft, reset];\r\n}\r\n"
    },
    {
      "id": "use-debounce",
      "name": "UseDebounce",
      "description": "Delays updating a value until after a specified time has passed.",
      "category": "Utilities",
      "package": "hook",
      "filePath": "packages\\hook\\src\\hooks\\use-debounce.ts",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "required": true
        },
        {
          "name": "delay",
          "type": "number",
          "required": true
        }
      ],
      "returns": {
        "type": "T"
      },
      "sourceCode": "import { useEffect, useState } from \"react\";\r\n\r\n/**\r\n * Delays updating a value until after a specified time has passed.\r\n */\r\nexport function useDebounce<T>(value: T, delay: number): T {\r\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\r\n\r\n  useEffect(() => {\r\n    const handler = setTimeout(() => {\r\n      setDebouncedValue(value);\r\n    }, delay);\r\n\r\n    return () => {\r\n      clearTimeout(handler);\r\n    };\r\n  }, [value, delay]);\r\n\r\n  return debouncedValue;\r\n}\r\n"
    },
    {
      "id": "use-fetch",
      "name": "UseFetch",
      "description": "Fetches data from a URL and returns loading and error states.",
      "category": "Uncategorized",
      "package": "hook",
      "filePath": "packages\\hook\\src\\hooks\\use-fetch.ts",
      "parameters": [
        {
          "name": "url",
          "type": "string",
          "required": true
        }
      ],
      "returns": {
        "type": "{ data: T; loading: boolean; error: Error; }"
      },
      "sourceCode": "import { useEffect, useState } from \"react\";\r\n\r\n/**\r\n * Fetches data from a URL and returns loading and error states.\r\n */\r\nexport function useFetch<T>(url: string) {\r\n  const [data, setData] = useState<T | null>(null);\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState<Error | null>(null);\r\n\r\n  useEffect(() => {\r\n    const fetchData = async () => {\r\n      setLoading(true);\r\n      try {\r\n        const response = await fetch(url);\r\n        const result = await response.json();\r\n        setData(result);\r\n      } catch (err) {\r\n        setError(err as Error);\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    };\r\n\r\n    fetchData();\r\n  }, [url]);\r\n\r\n  return { data, loading, error };\r\n}\r\n\r\nexport default useFetch;\r\n"
    },
    {
      "id": "use-hover",
      "name": "UseHover",
      "description": "Tracks whether an element is being hovered over.",
      "category": "Uncategorized",
      "package": "hook",
      "filePath": "packages\\hook\\src\\hooks\\use-hover.ts",
      "parameters": [
        {
          "name": "elementRef",
          "type": "React.RefObject<T>",
          "required": true
        }
      ],
      "returns": {
        "type": "boolean"
      },
      "sourceCode": "import { useEffect, useState } from \"react\";\r\n\r\n/**\r\n * Tracks whether an element is being hovered over.\r\n */\r\nexport function useHover<T extends HTMLElement>(\r\n  elementRef: React.RefObject<T>,\r\n): boolean {\r\n  // State to track hover status\r\n  const [isHovered, setIsHovered] = useState(false);\r\n\r\n  useEffect(() => {\r\n    const element = elementRef.current;\r\n\r\n    if (!element) return;\r\n\r\n    // Event handlers\r\n    const handleMouseEnter = () => setIsHovered(true);\r\n    const handleMouseLeave = () => setIsHovered(false);\r\n\r\n    // Attach event listeners\r\n    element.addEventListener(\"mouseenter\", handleMouseEnter);\r\n    element.addEventListener(\"mouseleave\", handleMouseLeave);\r\n\r\n    // Cleanup event listeners on unmount or ref change\r\n    return () => {\r\n      element.removeEventListener(\"mouseenter\", handleMouseEnter);\r\n      element.removeEventListener(\"mouseleave\", handleMouseLeave);\r\n    };\r\n  }, [elementRef]);\r\n\r\n  return isHovered;\r\n}\r\n"
    },
    {
      "id": "use-is-client",
      "name": "UseIsClient",
      "description": "Detects if the code is running on the client (browser) side.",
      "category": "Client-side",
      "package": "hook",
      "filePath": "packages\\hook\\src\\hooks\\use-is-client.ts",
      "parameters": [],
      "returns": {
        "type": "boolean"
      },
      "sourceCode": "import { useEffect, useState } from \"react\";\r\n\r\n/**\r\n * Detects if the code is running on the client (browser) side.\r\n */\r\nexport function useIsClient() {\r\n  const [isClient, setIsClient] = useState(false);\r\n\r\n  useEffect(() => {\r\n    setIsClient(true);\r\n  }, []);\r\n\r\n  return isClient;\r\n}\r\n"
    },
    {
      "id": "use-is-mobile",
      "name": "UseIsMobile",
      "description": "Detects if the current device is mobile based on screen width.",
      "category": "Client-side",
      "package": "hook",
      "filePath": "packages\\hook\\src\\hooks\\use-is-mobile.ts",
      "parameters": [],
      "returns": {
        "type": "boolean"
      },
      "sourceCode": "import * as React from \"react\";\r\n\r\nconst MOBILE_BREAKPOINT = 768;\r\n\r\n/**\r\n * Detects if the current device is mobile based on screen width.\r\n */\r\nexport function useIsMobile() {\r\n  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(\r\n    undefined,\r\n  );\r\n\r\n  React.useEffect(() => {\r\n    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`);\r\n    const onChange = () => {\r\n      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);\r\n    };\r\n    mql.addEventListener(\"change\", onChange);\r\n    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT);\r\n    return () => mql.removeEventListener(\"change\", onChange);\r\n  }, []);\r\n\r\n  return !!isMobile;\r\n}\r\n"
    },
    {
      "id": "use-isomorphic-layout-effect",
      "name": "UseIsomorphicLayoutEffect",
      "description": "Returns the appropriate layout effect hook based on the environment.\r\nUses `useLayoutEffect` in the browser and `useEffect` on the server.\r\n\r\nThis is useful for avoiding SSR warnings when using `useLayoutEffect`\r\nin components that are rendered on both server and client.",
      "category": "Uncategorized",
      "package": "hook",
      "filePath": "packages\\hook\\src\\hooks\\use-isomorphic-layout-effect.ts",
      "parameters": [],
      "returns": {
        "type": "typeof React.useLayoutEffect"
      },
      "sourceCode": "import { useEffect, useLayoutEffect } from \"react\";\r\n\r\n/**\r\n * Returns the appropriate layout effect hook based on the environment.\r\n * Uses `useLayoutEffect` in the browser and `useEffect` on the server.\r\n *\r\n * This is useful for avoiding SSR warnings when using `useLayoutEffect`\r\n * in components that are rendered on both server and client.\r\n *\r\n * @returns The appropriate effect hook for the current environment\r\n *\r\n * @example\r\n * ```tsx\r\n * const useIsomorphicLayoutEffect = useIsomorphicLayoutEffect();\r\n *\r\n * useIsomorphicLayoutEffect(() => {\r\n *   // This will use useLayoutEffect in browser, useEffect on server\r\n *   window.scrollTo(0, 0);\r\n * }, []);\r\n * ```\r\n */\r\nexport function useIsomorphicLayoutEffect() {\r\n  return typeof window !== \"undefined\" ? useLayoutEffect : useEffect;\r\n}\r\n"
    },
    {
      "id": "use-local-storage",
      "name": "UseLocalStorage",
      "description": "Persists state in browser's localStorage with automatic synchronization.",
      "category": "Utilities",
      "package": "hook",
      "filePath": "packages\\hook\\src\\hooks\\use-local-storage.ts",
      "parameters": [
        {
          "name": "key",
          "type": "string",
          "required": true
        },
        {
          "name": "initialValue",
          "type": "T",
          "required": true
        }
      ],
      "returns": {
        "type": "[T, (value: T) => void]"
      },
      "sourceCode": "import { useState } from \"react\";\r\n\r\n/**\r\n * Persists state in browser's localStorage with automatic synchronization.\r\n */\r\nexport function useLocalStorage<T>(\r\n  key: string,\r\n  initialValue: T,\r\n): [T, (value: T) => void] {\r\n  const [storedValue, setStoredValue] = useState<T>(() => {\r\n    try {\r\n      const item = window.localStorage.getItem(key);\r\n      return item ? (JSON.parse(item) as T) : initialValue;\r\n    } catch (error) {\r\n      console.error(error);\r\n      return initialValue;\r\n    }\r\n  });\r\n\r\n  const setValue = (value: T) => {\r\n    try {\r\n      setStoredValue(value);\r\n      window.localStorage.setItem(key, JSON.stringify(value));\r\n    } catch (error) {\r\n      console.error(error);\r\n    }\r\n  };\r\n\r\n  return [storedValue, setValue];\r\n}\r\n"
    },
    {
      "id": "use-media-query",
      "name": "UseMediaQuery",
      "description": "Tracks the state of a CSS media query.",
      "category": "Client-side",
      "package": "hook",
      "filePath": "packages\\hook\\src\\hooks\\use-media-query.ts",
      "parameters": [
        {
          "name": "query",
          "type": "string",
          "required": true
        }
      ],
      "returns": {
        "type": "boolean"
      },
      "sourceCode": "import { useEffect, useState } from \"react\";\r\n\r\n/**\r\n * Tracks the state of a CSS media query.\r\n */\r\nexport function useMediaQuery(query: string): boolean {\r\n  const [matches, setMatches] = useState<boolean>(false);\r\n\r\n  useEffect(() => {\r\n    const mediaQueryList = window.matchMedia(query);\r\n    const documentChangeHandler = () => setMatches(mediaQueryList.matches);\r\n\r\n    // Set the initial state\r\n    setMatches(mediaQueryList.matches);\r\n\r\n    // Listen for changes\r\n    mediaQueryList.addEventListener(\"change\", documentChangeHandler);\r\n\r\n    // Cleanup listener on unmount\r\n    return () => {\r\n      mediaQueryList.removeEventListener(\"change\", documentChangeHandler);\r\n    };\r\n  }, [query]);\r\n\r\n  return matches;\r\n}\r\n"
    },
    {
      "id": "use-network-status",
      "name": "UseNetworkStatus",
      "description": "Tracks the browser's online/offline network status.",
      "category": "Uncategorized",
      "package": "hook",
      "filePath": "packages\\hook\\src\\hooks\\use-network-status.ts",
      "parameters": [],
      "returns": {
        "type": "boolean"
      },
      "sourceCode": "import { useEffect, useState } from \"react\";\r\n\r\nconst isServer = typeof window !== \"undefined\";\r\n\r\n/**\r\n * Tracks the browser's online/offline network status.\r\n */\r\nexport function useNetworkStatus(): boolean {\r\n  const [isOnline, setIsOnline] = useState(\r\n    isServer ? true : window.navigator.onLine,\r\n  );\r\n\r\n  useEffect(() => {\r\n    const handleOnline = () => setIsOnline(true);\r\n    const handleOffline = () => setIsOnline(false);\r\n\r\n    window.addEventListener(\"online\", handleOnline);\r\n    window.addEventListener(\"offline\", handleOffline);\r\n\r\n    return () => {\r\n      window.removeEventListener(\"online\", handleOnline);\r\n      window.removeEventListener(\"offline\", handleOffline);\r\n    };\r\n  }, []);\r\n\r\n  return isOnline;\r\n}\r\n"
    },
    {
      "id": "use-on-screen",
      "name": "UseOnScreen",
      "description": "Detects when an element is visible in the viewport.",
      "category": "Uncategorized",
      "package": "hook",
      "filePath": "packages\\hook\\src\\hooks\\use-on-screen.ts",
      "parameters": [
        {
          "name": "ref",
          "type": "React.RefObject<Element>",
          "required": true
        },
        {
          "name": "rootMargin",
          "type": "string",
          "required": false,
          "defaultValue": "\"0px\""
        }
      ],
      "returns": {
        "type": "boolean"
      },
      "sourceCode": "import type { RefObject } from \"react\";\r\nimport { useEffect, useState } from \"react\";\r\n\r\n/**\r\n * Detects when an element is visible in the viewport.\r\n */\r\nexport function useOnScreen(\r\n  ref: RefObject<Element | null>,\r\n  rootMargin = \"0px\",\r\n): boolean {\r\n  const [isVisible, setIsVisible] = useState(false);\r\n\r\n  useEffect(() => {\r\n    if (ref.current == null) return;\r\n    const currentRef = ref.current;\r\n    const observer = new IntersectionObserver(\r\n      ([entry]) => setIsVisible(entry?.isIntersecting ?? false),\r\n      { rootMargin },\r\n    );\r\n    if (currentRef) observer.observe(currentRef);\r\n    return () => {\r\n      if (currentRef) observer.unobserve(currentRef);\r\n    };\r\n  }, [ref, rootMargin]);\r\n\r\n  return isVisible;\r\n}\r\n"
    },
    {
      "id": "use-throttle",
      "name": "UseThrottle",
      "description": "Limits value updates to at most once per specified interval.",
      "category": "Utilities",
      "package": "hook",
      "filePath": "packages\\hook\\src\\hooks\\use-throttle.ts",
      "parameters": [
        {
          "name": "value",
          "type": "T",
          "required": true
        },
        {
          "name": "delay",
          "type": "number",
          "required": true
        }
      ],
      "returns": {
        "type": "T"
      },
      "sourceCode": "import { useEffect, useState } from \"react\";\r\n\r\n/**\r\n * Limits value updates to at most once per specified interval.\r\n */\r\nexport function useThrottle<T>(value: T, delay: number): T {\r\n  const [throttledValue, setThrottledValue] = useState<T>(value);\r\n\r\n  useEffect(() => {\r\n    const handler = setTimeout(() => {\r\n      setThrottledValue(value);\r\n    }, delay);\r\n\r\n    // Cleanup the timeout if the effect runs again before the delay completes\r\n    return () => {\r\n      clearTimeout(handler);\r\n    };\r\n  }, [value, delay]);\r\n\r\n  return throttledValue;\r\n}\r\n"
    },
    {
      "id": "use-timeout",
      "name": "UseTimeout",
      "description": "A React hook to execute a callback function after a specified delay.",
      "category": "Utilities",
      "package": "hook",
      "filePath": "packages\\hook\\src\\hooks\\use-timeout.ts",
      "parameters": [
        {
          "name": "callback",
          "type": "() => void",
          "required": true
        },
        {
          "name": "delay",
          "type": "number",
          "required": true
        }
      ],
      "returns": {
        "type": "void"
      },
      "sourceCode": "import { useEffect, useRef } from \"react\";\r\n\r\n/**\r\n * A React hook to execute a callback function after a specified delay.\r\n *\r\n * @param callback - The function to execute after the timeout.\r\n * @param delay - The timeout duration in milliseconds. If `null`, the timeout will not run.\r\n */\r\n\r\nexport function useTimeout(callback: () => void, delay: number | null): void {\r\n  const callbackRef = useRef(callback);\r\n\r\n  // Update the callback reference if it changes.\r\n  useEffect(() => {\r\n    callbackRef.current = callback;\r\n  }, [callback]);\r\n\r\n  // Set the timeout.\r\n  useEffect(() => {\r\n    if (!delay && delay !== 0) {\r\n      return;\r\n    }\r\n\r\n    const id = setTimeout(() => {\r\n      callbackRef.current();\r\n    }, delay);\r\n\r\n    return () => {\r\n      clearTimeout(id);\r\n    };\r\n  }, [delay]);\r\n}\r\n"
    }
  ]
}